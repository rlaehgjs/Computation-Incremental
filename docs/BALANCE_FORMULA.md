# 게임 밸런스 공식 정리

## 1. 하드웨어 업그레이드 비용

### 1단계: 기본 비용 계산 (Base Scaling)
```
비용 = base × (exp ^ adjustedLevel)
```

### 2단계: 각 업그레이드별 상세 공식
| 업그레이드 | base | exp (기본) | exp (Spark Lv.3+) | 비고 |
|-----------|------|------------|---------------------|------|
| 열 확장 (cols) | 5 | 2.5 | 2.2 | Spark 1 해금 (최대 4~8) |
| 클럭 가속 (speed) | 10 | 1.6 | 1.48 | Spark 2 해금 (무제한) |
| 행 확장 (rows) | 50 | 3.5 | 3.0 | Spark 4 해금 (최대 4 고정) |
| 전압 최적화 (prob) | 1e8 | 50 | - | Spark 8 해금 (2%씩 증가) |

### 3단계: 가속(Scaling Acceleration) 및 adjustedLevel 계산
- **클럭 가속**: `adjustedLevel = level` (가속 없음)
- **행 확장 (Rows)**: `adjustedLevel = (level-1) + (level-1)^1.5` (1단계부터 가속)
- **열 확장 (Cols)**: 
  - Lv 1~4: `adjustedLevel = level-1`
  - Lv 5+: `adjustedLevel = (level-1) + (level-1 - 3)^1.5` (5단계 진입 시부터 가속)

### 비용 예시 (Spark Lv.3 미적용)
- **행 확장**: 50, 612, 21332, 1452725
- **열 확장**: 5, 12, 31, 78, 488, 6419, 143150, 4656612
- **클럭 가속**: 10, 16, 26, 41, 66, 105, 168, 268...

---

## 2. Cognitive Step 업그레이드 비용

### 발상 (Spark)
```
비용 = 5 × (2.5 ^ (현재레벨 ^ ((7/6) * scalingMult))) * costMult
```
- **scalingMult**: 기본 1.0, **충동 Lv.2 이상 시 0.8**
- **costMult**: 기본 1.0, **충동 Lv.1 이상 시 0.75**
- 레벨별 해금 요소:
    - Lv.4: **행 확장(Rows)** & 충동(Impulse) 해금
    - Lv.5: **기본 생산량 보너스** 해금
    - Lv.6: **콤보 보너스** 해금
    - Lv.7: **열 확장 한계 증가** 시작 (Lv.10에 최대 8)
    - Lv.8: **전압 최적화(Prob)** 업그레이드 해금
    - Lv.10: 생산량 보너스 **제곱(Squared)** 적용

### 충동 (Impulse)
- 비용: **0** (발상 레벨 리셋)
- 요구사항: **baseReq * reqMult** (발상 레벨)
  - **baseReq**: (현재 충동 Lv + 2)^2
  - **reqMult**: 기본 1.0, **충동 Lv.1 이상 시 0.75**
- 지배적 효과:
    - Lv.1: 발상 요구 레벨 25% 감소
    - Lv.2: 발상 비용 스케일링 20% 감소
    - Lv.3: 충동 레벨 비례 생산량 보너스 & 칩 완성

---

## 3. 생산량 계산 공식

### 기본 구조
```
생산량 = yieldMult × onCount × comboMult
```

### 1단계: 전구 점등 확률
```
실제 확률 = 50% + (hardware.prob * 2)%
(max 95%)
```

### 2단계: yieldMult 계산
```
sBonus = 1
if (발상 >= 5):
    sBonus = (발상 * 0.5 + 1)
    if (발상 >= 10): sBonus = sBonus ^ 2

iBonus = 1
if (충동 >= 3):
    iBonus = (충동 * 2 + 1)

yieldMult = sBonus * iBonus

maxCols = 4
if (발상 >= 7): maxCols = min(4 + (발상 - 6), 8)
```

**예시 (생산량 보너스):**
- 발상 5, 충동 0: x3.5
- 발상 10, 충동 0: x6.0^2 = x36.0
- 발상 10, 충동 3: x36.0 * (3 * 2 + 1) = x252.0

### 3단계: comboMult 계산 (발상 Lv.6+)
- **임계치($T$):** 전체 전구 개수의 50% (올림)
- **기본 공식:** `onCount > T` 일 때, `1 + 1.2 ^ (onCount - T)`
- **소프트캡:** 보너스가 100배를 초과할 경우, `100 + (현재보너스 - 100) ^ 0.5`

**콤보 보너스 예시 (그리드 16개, $T=8$ 기준):**
- 8개 이하: 1.0배
- 9개 (1개 초과): 1 + 1.2^1 = 2.2배
- 13개 (5개 초과): 1 + 1.2^5 ≈ 3.49배
- 20개 (12개 초과): 1 + 1.2^12 ≈ 9.92배
- 33개 초과 시(지수적 증가): 100배 돌파 후 소프트캡 적용

---

## 4.기본 사이클 간격(Delay)은 하드웨어 '클럭 가속(speed)' 레벨에 따라 지수적으로 감소합니다. 12레벨(약 200ms) 이후부터는 효율이 감소하는 소프트캡이 적용됩니다.

- **Lv.0 - Lv.11**: $1000 \times 0.87^{Lv}$
- **Lv.12+ (소프트캡)**: $12\text{레벨 딜레이} \times 0.93^{(Lv-11)}$ 이전 레벨들의 누적 효과에 더해 다음 레벨부터 0.93배가 적용됩니다.

**예시:**
- Speed 0: 1,000ms
- Speed 12: $1000 \times 0.87^{12} \approx 188\text{ms}$
- Speed 13: $188 \times 0.93 \approx 175\text{ms}$ (소프트캡 미적용 시 163ms)

---

## 5. 밸런스 분석

### 생산량 증가 요인
1. **하드웨어 확장**: 전구 수 증가 (rows × cols)
2. **클럭 가속**: 사이클 시간 감소
3. **점등 확률**: (발상 8 해금) 전압 최적화 하드웨어
4. **발상 (Spark) 단계**: 5레벨 보너스, 10레벨 제곱 보너스, 6레벨 콤보 해금
5. **충동 (Impulse) 단계**: 발상 요구량/비용 감소 및 3레벨 생산량 증폭

### 비용 증가 패턴
- **하드웨어**: 지수적 증가 + 가변 가속 (행 확장: Lv 1+, 열 확장: Lv 5+)
- **전압 최적화**: 초고속 가속 스케일링 ($50^{(Lv + Lv^{1.5})}$)
- **발상 (Spark)**: 지수의 지수 증가 ($2.5^{(Lv^{1.16...})}$)
- **충동 (Impulse)**: 리셋형 성장 (발상 요구량/비용 완화)

### 잠재적 밸런스 이슈
1. **행 확장(rows)**: 처음부터 가속 스케일링이 적용되어 빠르게 비싸짐 (충동 해금 요소)
2. **열 확장(cols)**: 발상 1로 조기 해금되지만, 5레벨부터 가속 스케일링 적용
3. **클럭 가속**: 1.6배 증가로 비교적 저렴하지만 효과는 지수적 (0.87^n, 12레벨 이후 0.93^n)
4. **콤보 보너스**: 지수적 성장 모델로 변경되어 후반부 폭발적인 생산량 제공 ($1.2^n$, 100배 이후 소프트캡)
