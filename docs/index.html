<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Computation-Incremental</title>
    <script src="https://cdn.jsdelivr.net/npm/break_eternity.js"></script>
    <style>
        :root {
            --neon: #00ff41;
            --bg: #050505;
            --white: #eee;
            --gray: #444;
            --panel-bg: #0a0a0a;
        }

        body {
            background: var(--bg);
            color: var(--white);
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tab-nav {
            width: 900px;
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            background: #111;
            border: 1px solid #333;
            color: #888;
            padding: 10px;
            cursor: pointer;
            text-align: center;
            font-weight: bold;
            transition: 0.2s;
        }

        .tab-btn:hover {
            background: #1a1a1a;
            color: #ccc;
        }

        .tab-btn.active {
            background: var(--panel-bg);
            border-color: var(--neon);
            color: var(--neon);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.1);
        }

        .tab-content {
            display: none;
            width: 900px;
        }

        .tab-content.active {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .header {
            width: 900px;
            display: flex;
            justify-content: space-between;
            border-bottom: 2px solid #222;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .bits-count {
            font-size: 28px;
            transition: 0.3s;
        }

        .bits-count.affordable {
            color: var(--neon);
            text-shadow: 0 0 10px var(--neon);
        }

        /* 패널 레이아웃 수정 */
        .panel-container {
            display: grid;
            grid-template-columns: 1.3fr 1fr;
            gap: 30px;
            width: 100%;
        }

        .panel {
            border: 1px solid #333;
            padding: 20px;
            background: var(--panel-bg);
            border-radius: 8px;
            min-height: 450px;
            position: relative;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .help-btn {
            background: none;
            border: 1px solid #333;
            color: #666;
            cursor: pointer;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            position: relative;
            vertical-align: middle;
            flex-shrink: 0;
        }

        .help-btn .tooltip {
            visibility: hidden;
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            border: 1px solid var(--neon);
            color: var(--white);
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 11px;
            z-index: 1000;
            pointer-events: none;
            display: block;
            width: auto;
            min-width: 200px;
            max-width: 400px;
            white-space: normal;
            word-wrap: break-word;
            word-break: break-word;
            text-align: left;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .help-btn:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .help-btn:hover .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: var(--neon);
            margin-bottom: -5px;
        }

        /* 회로 영역 (로그 위로 이동) */
        #circuit-area {
            width: 100%;
            background: var(--panel-bg);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 200px;
        }

        #bulb-grid {
            display: grid;
            gap: 8px;
            justify-content: center;
            margin-top: 10px;
        }

        .bulb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #1a1a1a;
            border: 2px solid #333;
            transition: background 0.05s, box-shadow 0.05s;
        }

        .bulb.on {
            background: #ffca28;
            border-color: #ffca28;
            box-shadow: 0 0 15px #ffca28, 0 0 5px #fff;
            z-index: 10;
        }

        button.action-btn {
            background: #111;
            color: var(--white);
            border: 1px solid var(--gray);
            padding: 12px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 12px;
            text-align: left;
            border-radius: 4px;
            position: relative;
            transition: 0.2s;
        }

        button.action-btn:hover:not(:disabled) {
            border-color: var(--neon);
            background: #161616;
            transform: translateX(2px);
        }

        button.action-btn.affordable {
            color: var(--neon);
            border-color: var(--neon);
        }

        button.action-btn:disabled {
            opacity: 0.75;
            cursor: not-allowed;
        }

        /* 숨김 처리 최우선 적용 (우선순위 강화) */
        .hidden,
        button.hidden,
        div.hidden {
            display: none !important;
        }

        button.action-btn.max-btn {
            width: 80px !important;
            min-width: 80px !important;
            max-width: 80px !important;
            margin: 0 !important;
            padding: 8px 4px !important;
            font-size: 11px !important;
            display: flex;
            flex-direction: column !important;
            justify-content: center !important;
            align-items: center !important;
            line-height: 1.2 !important;
            box-sizing: border-box !important;
            border-top-left-radius: 0 !important;
            border-bottom-left-radius: 0 !important;
            border-top-right-radius: 4px !important;
            border-bottom-right-radius: 4px !important;
            border-top: 1px solid var(--gray) !important;
            border-right: 1px solid var(--gray) !important;
            border-bottom: 1px solid var(--gray) !important;
            border-left: 1px dashed #666 !important;
            position: relative !important;
            z-index: 2 !important;
            flex-shrink: 0 !important;
        }

        button.action-btn.max-btn.affordable {
            border-left-color: #eee !important;
            border-top-color: var(--neon) !important;
            border-right-color: var(--neon) !important;
            border-bottom-color: var(--neon) !important;
            color: var(--neon) !important;
        }

        /* 분할 버튼 컨테이너 내에서는 움직임 효과 제거 (정렬 유지) */
        .hw-btn-container {
            display: flex;
            gap: 0;
            margin-bottom: 12px;
            align-items: stretch;
            overflow: visible !important;
            /* Max 버튼의 오른쪽 테두리가 잘리지 않도록 */
        }

        .hw-btn-container .action-btn:hover {
            transform: none;
        }

        /* Max 버튼이 숨겨졌을 때 메인 버튼의 오른쪽 모서리 복원 */
        .hw-btn-container .action-btn {
            border-top-right-radius: 4px !important;
            border-bottom-right-radius: 4px !important;
            border-right: 1px solid var(--gray) !important;
        }

        /* affordable 상태일 때 오른쪽 테두리도 초록색으로 */
        .hw-btn-container .action-btn.affordable {
            border-right-color: var(--neon) !important;
        }

        /* Max 버튼이 보일 때만 메인 버튼의 오른쪽 모서리 제거 */
        .hw-btn-container:has(.max-btn:not(.hidden))>.action-btn:first-child {
            border-top-right-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
            border-right: none !important;
        }

        .rank-title {
            font-size: 16px;
            font-weight: bold;
            display: block;
            margin-bottom: 4px;
            padding-right: 100px;
        }

        .cost-text {
            font-size: 13px;
            color: #aaa;
            position: absolute;
            top: 12px;
            right: 12px;
        }

        button.action-btn.affordable .cost-text {
            color: var(--neon);
        }

        .effect-info {
            font-size: 11px;
            color: #888;
            margin-top: 4px;
            display: block;
        }

        .milestones {
            border-top: 1px dashed #333;
            padding-top: 6px;
            margin-top: 8px;
            font-size: 11px;
        }

        /* 계층형 탭 스타일 추가 */
        .category-nav {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #222;
            padding-bottom: 15px;
        }

        .category-btn {
            background: #111;
            border: 1px solid #333;
            color: #888;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            flex: 1;
            transition: all 0.2s;
            font-weight: bold;
        }

        .category-btn.active {
            border-color: var(--neon);
            color: var(--neon);
            background: rgba(0, 255, 65, 0.05);
        }

        .sub-tab-nav {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            padding: 5px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
        }

        .sub-tab-btn {
            background: none;
            border: 1px solid transparent;
            color: #666;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .sub-tab-btn.active {
            color: #fff;
            background: #222;
            border: 1px solid #444;
        }

        .scaling-info-container {
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
        }

        .scaling-header {
            font-size: 18px;
            color: var(--neon);
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
        }

        .scaling-detail {
            color: #aaa;
            font-size: 14px;
            line-height: 1.6;
        }

        .scaling-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #222;
        }

        .scaling-item:last-child {
            border-bottom: none;
        }

        .ms-item {
            margin-bottom: 2px;
        }

        .ms-active {
            color: var(--neon);
            font-weight: bold;
        }

        .ms-future {
            color: #555;
        }

        .log {
            height: 100px;
            overflow-y: hidden;
            border: 1px solid #222;
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            width: 900px;
            padding: 10px;
            background: #000;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        .stat-line {
            padding: 8px;
            border-bottom: 1px solid #222;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            color: var(--neon);
            font-weight: bold;
            white-space: nowrap;
        }

        .setting-btn {
            background: #222;
            border: 1px solid #555;
            color: #eee;
            padding: 10px 20px;
            margin-bottom: 10px;
            cursor: pointer;
            width: 100%;
            text-align: left;
        }

        .setting-btn:hover {
            background: #333;
            border-color: #888;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-title {
            color: var(--neon);
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .sub-tab-nav {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            border-bottom: 1px solid #222;
            padding-bottom: 10px;
        }

        .sub-tab-btn {
            background: #111;
            border: 1px solid #333;
            color: #666;
            padding: 5px 15px;
            cursor: pointer;
            font-size: 12px;
            border-radius: 4px;
            transition: 0.2s;
        }

        .sub-tab-btn:hover {
            color: #aaa;
            border-color: #555;
        }

        .sub-tab-btn.active {
            background: #222;
            color: var(--neon);
            border-color: var(--neon);
        }

        /* 컷신 레이어 스타일 */
        #cutscene-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        #cutscene-image-container {
            width: 80%;
            height: 60%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            border: 1px solid #222;
            background: #050505;
        }

        #cutscene-image {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: opacity 0.5s;
        }

        #cutscene-text-box {
            width: 80%;
            min-height: 100px;
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid var(--neon);
            padding: 20px;
            box-sizing: border-box;
            color: var(--white);
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px #000;
            backdrop-filter: blur(5px);
        }

        .cutscene-controls {
            display: flex;
            gap: 20px;
            width: 80%;
        }

        .cutscene-btn {
            padding: 12px 30px;
            background: transparent;
            border: 1px solid var(--neon);
            color: var(--neon);
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: 0.3s;
        }

        .cutscene-btn:hover {
            background: var(--neon);
            color: #000;
            box-shadow: 0 0 15px var(--neon);
        }

        .cutscene-btn:disabled {
            border-color: #333;
            color: #333;
            cursor: not-allowed;
            box-shadow: none;
        }

        .skip-btn {
            margin-left: auto;
            border-color: #666;
            color: #666;
        }

        .skip-btn:hover {
            border-color: #fff;
            color: #fff;
            background: transparent;
            box-shadow: 0 0 10px #fff;
        }

        /* 챕터 타이틀 연출 스타일 */
        #chapter-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 1s;
        }

        #chapter-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .chapter-bulb-icon {
            width: 80px;
            height: 80px;
            fill: var(--neon);
            filter: drop-shadow(0 0 10px var(--neon));
            margin-bottom: 20px;
            opacity: 0;
            transform: translateY(20px);
        }

        .chapter-bulb-icon.animate {
            animation: fadeInRise 1s forwards 0.5s;
        }

        #chapter-main-text {
            font-size: 48px;
            font-weight: bold;
            color: var(--white);
            letter-spacing: 15px;
            margin: 0;
            transform: scaleX(0);
            transform-origin: center;
            white-space: nowrap;
        }

        #chapter-main-text.animate {
            animation: expandHorizontal 1.2s cubic-bezier(0.87, 0, 0.13, 1) forwards 1s;
        }

        #chapter-sub-text {
            font-size: 20px;
            color: var(--neon);
            margin-top: 15px;
            opacity: 0;
            letter-spacing: 8px;
        }

        #chapter-sub-text.animate {
            animation: fadeInLetterSpacing 1.5s ease-out forwards 2s;
        }

        @keyframes expandHorizontal {
            from {
                transform: scaleX(0);
            }

            to {
                transform: scaleX(1);
            }
        }

        @keyframes fadeInRise {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInLetterSpacing {
            from {
                opacity: 0;
                letter-spacing: 25px;
            }

            to {
                opacity: 1;
                letter-spacing: 8px;
            }
        }
    </style>
</head>

<body>

    <div id="cutscene-overlay" class="hidden">
        <div id="cutscene-image-container">
            <img id="cutscene-image" src="" alt="Story Image">
        </div>
        <div id="cutscene-text-box"></div>
        <div class="cutscene-controls">
            <button id="cutscene-prev" class="cutscene-btn" onclick="prevCutscene()">이전</button>
            <button id="cutscene-next" class="cutscene-btn" onclick="nextCutscene()">다음</button>
            <button class="cutscene-btn skip-btn" onclick="skipCutscene()">스토리 스킵</button>
        </div>
    </div>

    <div id="chapter-overlay">
        <svg class="chapter-bulb-icon" viewBox="0 0 24 24">
            <path
                d="M12,2A7,7,0,0,0,5,9c0,2.38,1.19,4.47,3,5.74V17a1,1,0,0,0,1,1h6a1,1,0,0,0,1-1V14.74c1.81-1.27,3-3.36,3-5.74A7,7,0,0,0,12,2Zm2,14H10V14.15l1-0.7c1.33-0.93,1.33-0.93,1.33-2.45h1.34c0,1.52,0,1.52,1.33,2.45l1,0.7V16ZM11.33,9h1.34V12H11.33V9ZM15,19H9v1a1,1,0,0,0,1,1h4a1,1,0,0,0,1-1V19Z" />
        </svg>
        <h1 id="chapter-main-text">CHAPTER 1</h1>
        <div id="chapter-sub-text">모든 것의 시작</div>
    </div>

    <div class="header">
        <div id="bit-container" class="bits-count">비트: <span id="bits">0</span></div>
        <div style="text-align: right;">
            Ver 0.0.1<br>
            자동 저장: <span id="save-timer">60</span>s
        </div>
    </div>

    <div class="tab-nav">
        <div class="tab-btn active" onclick="switchTab('main')">메인 시스템</div>
        <div class="tab-btn" onclick="switchTab('stats')">핵심 통계</div>
        <div class="tab-btn" onclick="switchTab('settings')">설정</div>
    </div>

    <div id="tab-main" class="tab-content active">
        <div class="panel-container">
            <div class="panel">
                <div class="section-header">
                    <h3 style="color: var(--neon); margin:0;">하드웨어 제어</h3>
                    <button class="help-btn">? <span class="tooltip">전구는 매 사이클마다 50% 확률로 켜지며 정보를 생산합니다.</span></button>
                </div>

                <div id="hw-controls">
                    <!-- 행 추가 (Rows) -->
                    <div id="btn-group-rows" class="hidden">
                        <div class="hw-btn-container">
                            <button id="btn-rows" class="action-btn" onclick="buyHW('rows')"
                                style="flex: 1; margin: 0; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; position: relative; z-index: 1;">
                                <span class="rank-title">행 확장</span>
                                <span id="c-rows" class="cost-text">50 비트 소모</span>
                                <span id="eff-rows" class="effect-info">행: 1 -> 2 (최대 4)</span>
                            </button>
                            <button id="btn-rows-max" class="action-btn max-btn hidden" onclick="buyHWMax('rows')">
                                <span class="max-count">Max +0</span>
                                <span class="max-cost" style="color: #aaa;">0</span>
                            </button>
                        </div>
                    </div>

                    <!-- 클럭 가속 (Speed) -->
                    <div id="btn-group-speed" class="hidden">
                        <div class="hw-btn-container">
                            <button id="btn-speed" class="action-btn" onclick="buyHW('speed')"
                                style="flex: 1; margin: 0; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; position: relative; z-index: 1;">
                                <span class="rank-title">클럭 가속</span>
                                <span id="c-speed" class="cost-text">10 비트 소모</span>
                                <span id="eff-speed" class="effect-info">연산주기: 1000ms -> 900ms</span>
                            </button>
                            <button id="btn-speed-max" class="action-btn max-btn hidden" onclick="buyHWMax('speed')">
                                <span class="max-count">Max +0</span>
                                <span class="max-cost" style="color: #aaa;">0</span>
                            </button>
                        </div>
                    </div>

                    <!-- 열 추가 (Cols) -->
                    <div id="btn-group-cols" class="hidden">
                        <div class="hw-btn-container">
                            <button id="btn-cols" class="action-btn" onclick="buyHW('cols')"
                                style="flex: 1; margin: 0; border-top-right-radius: 0; border-bottom-right-radius: 0; border-right: none; position: relative; z-index: 1;">
                                <span class="rank-title">열 확장</span>
                                <span id="c-cols" class="cost-text">5 비트 소모</span>
                                <span id="eff-cols" class="effect-info">열: 1 -> 2 (최대 4)</span>
                            </button>
                            <button id="btn-cols-max" class="action-btn max-btn hidden" onclick="buyHWMax('cols')">
                                <span class="max-count">Max +0</span>
                                <span class="max-cost" style="color: #aaa;">0</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="section-header">
                    <h3 style="color: var(--neon); margin:0;">인지 단계</h3>
                    <button class="help-btn">? <span class="tooltip">상위 단계 진입 시 하위 단계 자원을 소모합니다.</span></button>
                </div>

                <div id="rank-controls">
                    <button id="btn-spark" class="action-btn" onclick="rankUp('spark')">
                        <span class="rank-title">발상 Lv.<span id="lv-spark">0</span></span>
                        <span id="c-spark" class="cost-text">5 비트 소모</span>
                        <div id="ms-spark" class="milestones"></div>
                    </button>
                    <button id="btn-impulse" class="action-btn hidden" onclick="rankUp('impulse')">
                        <span class="rank-title">충동 Lv.<span id="lv-impulse">0</span></span>
                        <span id="c-impulse" class="cost-text">발상 Lv.4 필요</span>
                        <div id="ms-impulse" class="milestones"></div>
                    </button>
                </div>
            </div>
        </div>

        <div id="circuit-area">
            <h3 style="color: #666; font-size: 14px; margin: 0 0 10px 0;">실시간 연산 현황</h3>
            <div id="bulb-grid" style="color: #444; font-size: 12px;">초기화 중...</div>
        </div>
    </div>

    <div id="tab-stats" class="tab-content container">
        <div class="panel" style="grid-column: span 2;">
            <div class="section-header">
                <h3 style="color: var(--neon); margin:0;">효과 디렉토리</h3>
            </div>
            <div class="category-nav">
                <button id="cat-system" class="category-btn active" onclick="switchCategory('system')">시스템 요약</button>
                <button id="cat-cognitive" class="category-btn" onclick="switchCategory('cognitive')">인지 단계 보너스</button>
                <button id="cat-scaling" class="category-btn" onclick="switchCategory('scaling')">연구 버전</button>
            </div>
            <div id="sub-tab-container" class="sub-tab-nav hidden">
                <!-- 동적으로 생성되는 서브 탭들 -->
            </div>
            <div id="stats-list" style="border-top: 1px solid #222; padding-top: 10px;"></div>
        </div>
    </div>

    <div id="tab-settings" class="tab-content container">
        <div class="panel" style="grid-column: span 2;">
            <div class="setting-group">
                <div class="setting-title">게임 설정</div>
                <div class="setting-item"
                    style="display: flex; justify-content: space-between; align-items: center; padding: 10px; border: 1px solid #333; margin-bottom: 10px; border-radius: 4px;">
                    <span>오프라인 진행 허용</span>
                    <button id="setting-offline" class="setting-btn" style="width: 100px; margin: 0;"
                        onclick="toggleSetting('offlineProgress')">ON</button>
                </div>
            </div>
            <div class="setting-group">
                <div class="setting-title">데이터 관리</div>
                <button class="setting-btn" onclick="saveGame(true)">강제 저장</button>
                <button class="setting-btn" onclick="exportGame()">데이터 내보내기 (클립보드 복사)</button>
                <button class="setting-btn" onclick="importGame()">데이터 불러오기 (텍스트 입력)</button>
                <button class="setting-btn" onclick="resetGame()" style="color: #f88; border-color: #522;">전체
                    초기화</button>
                <button class="setting-btn" style="margin-top: 10px;" onclick="showCutscene('intro')">스토리 다시 보기</button>
            </div>
        </div>
    </div>

    <div class="log" id="game-log">> 시스템 준비 완료.</div>

    <script>
        let bits = new Decimal(0);
        let hardware = { rows: 1, cols: 1, speed: 0, prob: 0 };
        let ranks = { spark: 0, impulse: 0 };
        let maxSpark = 0; // 최고 달성 발상 레벨
        let maxMkTier = 1; // 최고 도달 Mk 버전 (동적 탭 생성용)
        let consecutiveZeroTicks = 0; // 연속으로 0이 나온 틱 횟수 (3틱 보장용)
        let settings = { offlineProgress: true }; // 기본 설정
        let rankData = null; // JSON에서 로드됨
        let activeCategory = 'system';
        let activeSubTab = '';

        // 스토리 컷신 데이터
        const storyData = {
            intro: [
                { img: 'assets/images/cutscenes/1-1-NW.png', text: '졸업장은 냄비 받침으로 쓴 지 오래다. 멍청한 상사, 의미 없는 회의... 그런 건 내 알 바 아니다. 나에겐 이 고철들이 더 대하기 편하니까.' },
                { img: 'assets/images/cutscenes/1-2-NW.png', text: '하지만 천재도 밥은 먹어야 한다. 월세 낼 날짜는 다가오고, 남은 건 창고 가득한 재고 부품들 뿐.' },
                { img: 'assets/images/cutscenes/1-3-NW.png', text: '팔아서 돈을 만들 수 없다면, 만들어서 돈을 벌게 하면 된다. 기존의 컴퓨터 구조는 너무 비효율적이야. 내가 직접 설계한다. 이론상 완벽한, 무한 연산기를.' },
                { img: 'assets/images/cutscenes/1-4-NW.png', text: '시스템 가동. ...시작해 볼까?' }
            ]
        };

        let currentStory = null;
        let currentCutsceneIndex = 0;
        let isGamePaused = false;

        window.showCutscene = function (storyId) {
            currentStory = storyData[storyId];
            if (!currentStory) return;

            currentCutsceneIndex = 0;
            isGamePaused = true;
            document.getElementById('cutscene-overlay').classList.remove('hidden');
            updateCutsceneUI();
        }

        function updateCutsceneUI() {
            const scene = currentStory[currentCutsceneIndex];
            document.getElementById('cutscene-image').src = scene.img;
            document.getElementById('cutscene-text-box').innerText = scene.text;

            document.getElementById('cutscene-prev').disabled = (currentCutsceneIndex === 0);
            document.getElementById('cutscene-next').innerText = (currentCutsceneIndex === currentStory.length - 1) ? "시작하기" : "다음";
        }

        window.nextCutscene = function () {
            if (currentCutsceneIndex < currentStory.length - 1) {
                currentCutsceneIndex++;
                updateCutsceneUI();
            } else {
                skipCutscene();
            }
        }

        window.prevCutscene = function () {
            if (currentCutsceneIndex > 0) {
                currentCutsceneIndex--;
                updateCutsceneUI();
            }
        }

        window.skipCutscene = function () {
            document.getElementById('cutscene-overlay').classList.add('hidden');
            playChapterAnimation();
        }

        window.playChapterAnimation = function () {
            const overlay = document.getElementById('chapter-overlay');
            const bulb = overlay.querySelector('.chapter-bulb-icon');
            const mainText = document.getElementById('chapter-main-text');
            const subText = document.getElementById('chapter-sub-text');

            overlay.classList.add('active');
            bulb.classList.add('animate');
            mainText.classList.add('animate');
            subText.classList.add('animate');

            setTimeout(() => {
                overlay.classList.remove('active');
                // 애니메이션 클래스 제거 (나중에 다시 볼 때를 위해)
                setTimeout(() => {
                    bulb.classList.remove('animate');
                    mainText.classList.remove('animate');
                    subText.classList.remove('animate');

                    isGamePaused = false;
                    if (!gameLoopStarted) {
                        gameLoopStarted = true;
                        gameLoop();
                    }
                    saveGame();
                }, 1000);
            }, 5000); // 5초 동안 노출
        }

        function format(value, places = 3) {
            let d = new Decimal(value);
            if (d.lt(1e6)) {
                return d.floor().toString();
            }
            return d.toExponential(places).replace("+", "");
        }

        // rankData.json 파일에서 cognitive step 데이터 로드
        async function loadRankData() {
            try {
                // 현재 페이지의 경로를 기준으로 rankData.json 경로 설정 (캐시 무효화)
                const jsonPath = new URL('rankData.json', window.location.href).href;
                const cacheBuster = `?t=${Date.now()}`;
                const response = await fetch(jsonPath + cacheBuster);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                rankData = data;
                console.log('rankData 로드 성공:', rankData);
                return true;
            } catch (error) {
                console.error('rankData 로드 실패:', error);
                console.error('시도한 경로:', new URL('rankData.json', window.location.href).href);
                alert(`게임 데이터를 불러올 수 없습니다.\n에러: ${error.message}\n\n페이지를 새로고침해주세요.`);
                return false;
            }
        }

        function saveGame(notify = false) {
            const saveObj = {
                bits: bits.toString(),
                hardware: hardware,
                ranks: ranks,
                maxSpark: maxSpark,
                maxMkTier: maxMkTier,
                settings: settings,
                lastSaveTime: Date.now()
            };
            localStorage.setItem('infCompSave', JSON.stringify(saveObj));
            if (notify) addLog("데이터가 성공적으로 저장되었습니다.");
        }

        window.exportGame = function () {
            saveGame();
            const saveStr = localStorage.getItem('infCompSave');
            const encoded = btoa(unescape(encodeURIComponent(saveStr)));
            navigator.clipboard.writeText(encoded).then(() => {
                addLog("세이브 데이터가 클립보드에 복사되었습니다.");
            }).catch(err => {
                console.error('클립보드 복사 실패:', err);
                addLog("복사에 실패했습니다. 콘솔을 확인해주세요.");
            });
        }

        window.importGame = function () {
            const input = prompt("내보내기 했던 세이브 문자열을 입력해주세요:");
            if (!input) return;

            try {
                const decoded = decodeURIComponent(escape(atob(input)));
                const saveObj = JSON.parse(decoded);

                if (saveObj.bits && saveObj.hardware && saveObj.ranks) {
                    localStorage.setItem('infCompSave', decoded);
                    addLog("데이터를 성공적으로 불러왔습니다. 페이지를 새로고침합니다.");
                    setTimeout(() => location.reload(), 1000);
                } else {
                    throw new Error("유효하지 않은 세이브 데이터 형식입니다.");
                }
            } catch (e) {
                addLog("데이터를 불러오는 데 실패했습니다: " + e.message);
            }
        }

        function loadGame() {
            const saveStr = localStorage.getItem('infCompSave');
            if (saveStr) {
                try {
                    const saveObj = JSON.parse(saveStr);
                    bits = new Decimal(saveObj.bits);
                    hardware = saveObj.hardware;
                    ranks = saveObj.ranks;
                    // 호환성을 위한 예외 처리 (이전 버전에서 impulse/intuition이었을 경우)
                    if (saveObj.ranks.impulse !== undefined && saveObj.ranks.spark === undefined) {
                        ranks.spark = saveObj.ranks.impulse;
                        ranks.impulse = saveObj.ranks.intuition || 0;
                    }
                    maxSpark = saveObj.maxSpark || ranks.spark || 0;
                    maxMkTier = saveObj.maxMkTier || 1; // 기존 세이브 호환성
                    if (saveObj.settings) settings = { ...settings, ...saveObj.settings };
                    // 전압 최적화(prob) 누락 시 초기화 (기존 플레이어 호환성)
                    if (hardware.prob === undefined) hardware.prob = 0;

                    addLog("데이터 로드 완료.");

                    // 오프라인 진행 계산
                    if (saveObj.lastSaveTime) {
                        processOfflineProgress(saveObj.lastSaveTime);
                    }
                } catch (e) { }
            }
        }

        window.resetGame = function () {
            if (confirm("모든 데이터를 삭제하고 초기화하시겠습니까?")) {
                localStorage.removeItem('infCompSave');
                // 초기화 후 컷신부터 보여주기 위해 새로고침 대신 초기 상태로 돌림
                bits = new Decimal(0);
                hardware = { rows: 1, cols: 1, speed: 0, prob: 0 };
                ranks = { spark: 0, impulse: 0 };
                maxSpark = 0;
                maxMkTier = 1;
                consecutiveZeroTicks = 0;
                localStorage.setItem('infCompFirstTime', 'true');
                showCutscene('intro');
                initGrid();
                updateUI();
            }
        }

        // 최대 가로 크기 계산 (기본 4, 발상 5+ 레벨마다 +1)
        function getMaxCols() {
            let baseMax = 4;
            if (ranks.spark >= 7) {
                return Math.min(baseMax + (ranks.spark - 6), 8);
            }
            return baseMax;
        }

        const getHWCost = (type) => {
            let base = { rows: 50, cols: 5, speed: 10 }[type];
            let exp = { rows: 3.5, cols: 2.5, speed: 1.6 }[type];
            let lv = type === 'speed' ? hardware.speed : (type === 'rows' ? hardware.rows - 1 : hardware.cols - 1);

            // 하드웨어 비용 스케일링 감소 (충동 1레벨)
            if (ranks.impulse >= 1) exp = 1 + (exp - 1) * 0.8;

            // 행(rows) 스케일링 가속 (Level 1부터 적용)
            if (type === 'rows') {
                let currentLevel = hardware.rows - 1;
                // Level 1: adj=0 (Cost 50), Level 2: adj=2 (Cost 612), Level 3: adj=4.8 (Cost 21k)
                let adjustedExp = currentLevel + Math.pow(currentLevel, 1.5);
                let cost = new Decimal(base).times(Decimal.pow(exp, adjustedExp)).floor();
                if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                return cost;
            }

            // 가로(cols) 레벨 5 이상으로 올릴 때 비용 증가율 가속
            if (type === 'cols' && hardware.cols >= 5) {
                let currentLevel = hardware.cols - 1;
                // Level 5: adj=5 (Cost 488), Level 6: adj=7.8 (Cost 6.4k)
                let adjustedExp = currentLevel + Math.pow(currentLevel - 3, 1.5);
                let cost = new Decimal(base).times(Decimal.pow(exp, adjustedExp)).floor();
                if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                return cost;
            }


            let cost = new Decimal(base).times(Decimal.pow(exp, lv)).floor();
            if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
            return cost;
        };

        const getRankCost = (id) => {
            if (id === 'impulse') return 0; // 필요 Spark 레벨로 계산됨
            if (id === 'spark') {
                let scalingMult = 1.0;
                // 발상 비용 스케일링 감소 (충동 1레벨)
                if (ranks.impulse >= 1) scalingMult = 0.8;
                let exponent = Math.pow(ranks.spark, 1.2);
                let baseCost = Decimal.pow(1 + 2 * scalingMult, exponent).times(5);
                if (ranks.impulse >= 1) baseCost = baseCost.times(0.75);

                return baseCost.floor();
            }
            return new Decimal(rankData[id].baseCost).times(Decimal.pow(rankData[id].scale, ranks[id])).floor();
        }

        window.switchTab = function (tabName) {
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            const tabMap = { 'main': 0, 'stats': 1, 'settings': 2 };
            document.querySelectorAll('.tab-btn')[tabMap[tabName]].classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');
            if (tabName === 'stats') renderStats();
        }

        window.switchCategory = function (catId) {
            activeCategory = catId;
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.toggle('active', btn.id === `cat-${catId}`);
            });

            const subNav = document.getElementById('sub-tab-container');
            if (catId === 'system') {
                subNav.classList.add('hidden');
                activeSubTab = '';
            } else if (catId === 'cognitive') {
                subNav.classList.remove('hidden');
                renderSubTabs(['spark', 'impulse']);
                // 기본으로 'spark' 선택
                if (activeSubTab !== 'spark' && activeSubTab !== 'impulse') activeSubTab = 'spark';
            } else if (catId === 'scaling') {
                subNav.classList.remove('hidden');
                // Mk.N 버전 동적 생성 (Mk.2부터 maxMkTier까지)
                let mkTiers = [];
                for (let i = 2; i <= maxMkTier; i++) {
                    mkTiers.push(`mk${i}`);
                }

                if (mkTiers.length > 0) {
                    renderSubTabs(mkTiers);
                    if (!mkTiers.includes(activeSubTab)) activeSubTab = mkTiers[0];
                } else {
                    subNav.classList.add('hidden');
                    activeSubTab = '';
                }
            }
            renderStats();
        }

        function renderSubTabs(ids) {
            const container = document.getElementById('sub-tab-container');
            const labels = {
                'spark': '발상', 'impulse': '충동',
                'mk2': 'Mk.2', 'mk3': 'Mk.3', 'mk4': 'Mk.4', 'mk5': 'Mk.5'
            };
            container.innerHTML = ids.map(id => `
                <button class="sub-tab-btn ${activeSubTab === id ? 'active' : ''}" onclick="switchSubTab('${id}')">
                    ${labels[id] || id}
                </button>
            `).join('');
        }

        window.switchSubTab = function (subTabId) {
            activeSubTab = subTabId;
            document.querySelectorAll('.sub-tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('onclick').includes(`'${subTabId}'`));
            });
            renderStats();
        }

        window.buyHW = function (type) {
            // 최대 구매 모드 확인 삭제됨 (함수 분리)

            // 세로 최대치: 4 (발상 10 이상이면 +2?) - 일단 4로 고정
            let maxRows = 4;
            if (type === 'rows' && hardware.rows >= maxRows) return;

            // 가로 최대치: 기본 4, 발상 5+ 레벨마다 +1
            if (type === 'cols' && hardware.cols >= getMaxCols()) return;

            // 단일 구매 로직
            let cost = getHWCost(type);
            if (bits.gte(cost)) {
                bits = bits.minus(cost);
                hardware[type]++;
                if (type === 'rows' || type === 'cols') initGrid();
                updateUI();
                saveGame();
            }
        }

        function calcMaxAffordable(type) {
            let maxRows = 4;
            let current = hardware[type];
            let maxLimit = type === 'rows' ? maxRows : (type === 'cols' ? getMaxCols() : 9999);

            // 이미 최대치면 0 리턴
            if (current >= maxLimit) return { count: 0, cost: new Decimal(0) };
            if (type === 'prob' && 50 + (current * 2) >= 95) return { count: 0, cost: new Decimal(0) };

            let count = 0;
            let totalCost = new Decimal(0);
            let tempBits = new Decimal(bits);

            // 시뮬레이션 (최대 100회)
            // 비용은 레벨이 오를 때마다 변하므로 getHWCost 로직을 따라가야 함
            // 하지만 getHWCost는 global hardware state를 참조하므로,
            // 임시 변수로 계산하거나, 수식을 직접 써야 함.
            // 가장 안전한 방법: hardware 상태를 잠시 조작하고 복구 (단, 렌더링 사이클 내 동기 실행이므로 안전)
            // 하지만 부작용 우려가 있으므로, getHWCost의 복사본 로직을 사용하는 것이 좋음.
            // 여기서는 간단히 루프 내에서 비용 계산만 수행 (하드웨어 상태 변경 없이)

            let simLevel = current;

            for (let i = 0; i < 100; i++) {
                if (simLevel >= maxLimit) break;

                // 비용 계산 (getHWCost 로직 복제/변형)
                let base = { rows: 50, cols: 5, speed: 10 }[type];
                let exp = { rows: 3.5, cols: 2.5, speed: 1.6 }[type];
                let lv = type === 'speed' ? simLevel : simLevel - 1; // rows/cols는 lv-1 사용

                // 하드웨어 비용 스케일링 감소 (충동 1레벨)
                if (ranks.impulse >= 1) exp = 1 + (exp - 1) * 0.8;

                if (type === 'rows') {
                    // getHWCost의 rows 로직
                    let currentLevel = simLevel - 1;
                    let adjustedExp = currentLevel + Math.pow(currentLevel, 1.5);
                    let cost = new Decimal(base).times(Decimal.pow(exp, adjustedExp)).floor();
                    if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                    if (tempBits.lt(cost)) break;
                    totalCost = totalCost.plus(cost);
                    tempBits = tempBits.minus(cost);
                    count++;
                    simLevel++;
                }
                else if (type === 'cols') {
                    // getHWCost의 cols 로직
                    if (simLevel >= 5) {
                        let currentLevel = simLevel - 1;
                        let adjustedExp = currentLevel + Math.pow(currentLevel - 3, 1.5);
                        let cost = new Decimal(base).times(Decimal.pow(exp, adjustedExp)).floor();
                        if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                        if (tempBits.lt(cost)) break;
                        totalCost = totalCost.plus(cost);
                        tempBits = tempBits.minus(cost);
                        count++;
                        simLevel++;
                    } else {
                        let cost = new Decimal(base).times(Decimal.pow(exp, lv)).floor();
                        if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                        if (tempBits.lt(cost)) break;
                        totalCost = totalCost.plus(cost);
                        tempBits = tempBits.minus(cost);
                        count++;
                        simLevel++;
                    }
                }
                else {
                    // Speed (일반 로직)
                    let cost = new Decimal(base).times(Decimal.pow(exp, lv)).floor();
                    if (ranks.impulse >= 1) cost = cost.times(0.75).floor();
                    if (tempBits.lt(cost)) break;
                    totalCost = totalCost.plus(cost);
                    tempBits = tempBits.minus(cost);
                    count++;
                    simLevel++;
                }
            }

            return { count: count, cost: totalCost };
        }

        window.buyHWMax = function (type) {
            let result = calcMaxAffordable(type);
            if (result.count > 0) {
                if (bits.gte(result.cost)) {
                    bits = bits.minus(result.cost);
                    hardware[type] += result.count;
                    if (type === 'rows' || type === 'cols') initGrid();
                    updateUI();
                    saveGame();
                }
            }
        }

        window.rankUp = function (id) {
            if (id === 'spark') {
                let cost = getRankCost(id);
                if (bits.lt(cost)) return;

                bits = new Decimal(0);
                ranks.spark++;
                maxSpark = Math.max(maxSpark, ranks.spark);
                hardware = { rows: 1, cols: 1, speed: 0, prob: 0 };
                consecutiveZeroTicks = 0;
                addLog(`발상 Lv.${ranks.spark}: 사고 확장.`);
            }
            else if (id === 'impulse') {
                let req = Math.pow(ranks.impulse + 2, 2);
                if (ranks.spark < req) return;

                ranks.impulse++;
                ranks.spark = 0;
                bits = new Decimal(0);
                hardware = { rows: 1, cols: 1, speed: 0, prob: 0 };
                consecutiveZeroTicks = 0;
                addLog(`충동 Lv.${ranks.impulse}: 충동 단계 승급.`);
            }
            initGrid();
            updateUI();
            saveGame();
        }

        function calculateDelay(speedLevel) {
            let delay = 1000;
            for (let i = 0; i < speedLevel; i++) {
                if (i < 12) {
                    delay *= 0.87;
                } else {
                    delay *= 0.93;
                }
            }
            return delay;
        }

        function gameLoop() {
            if (isGamePaused) {
                setTimeout(gameLoop, 100);
                return;
            }
            let delay = calculateDelay(hardware.speed);
            delay = Math.max(delay, 16);
            bits = bits.plus(getTickYield(true));
            updateUI();
            setTimeout(gameLoop, delay);
        }

        function getTickYield(doFlash = false) {
            let prob = 50;
            let onCount = 0;
            let total = hardware.rows * hardware.cols;
            for (let i = 0; i < total; i++) {
                if (Math.random() * 100 < prob) {
                    onCount++;
                    if (doFlash) flash(i);
                }
            }

            // 3틱 보장 메커니즘
            if (onCount === 0) {
                consecutiveZeroTicks++;

                if (consecutiveZeroTicks >= 3) {
                    // 강제로 랜덤 전구 1개 켜기
                    const randomIndex = Math.floor(Math.random() * total);
                    onCount = 1;
                    if (doFlash) flash(randomIndex);
                    consecutiveZeroTicks = 0; // 리셋
                } else {
                    // 아직 3틱 안 됨
                    return new Decimal(0);
                }
            } else {
                // 정상적으로 전구가 켜진 경우 카운터 리셋
                consecutiveZeroTicks = 0;
            }

            let formulaBonus = new Decimal(1);

            // 발상 5레벨 보너스
            if (ranks.spark >= 5) {
                let sBonus = ranks.spark * 0.5 + 1;
                // 충동 2레벨: 발상 보너스 제곱
                if (ranks.impulse >= 2) {
                    sBonus = sBonus ** 2;
                }
                formulaBonus = formulaBonus.times(sBonus);
            }

            // 충동 2레벨: 충동 비례 보너스 (독립 적용)
            if (ranks.impulse >= 2) {
                let iBonus = ranks.impulse * 2 + 1;
                formulaBonus = formulaBonus.times(iBonus);
            }

            let yieldMult = formulaBonus;

            let comboMult = new Decimal(1);
            // 발상 6레벨 콤보 해금
            if (ranks.spark >= 6) {
                let threshold = Math.ceil((hardware.rows * hardware.cols) / 2);
                if (onCount > threshold) {
                    let bonusRaw = 1.2 ** (onCount - threshold);
                    if (bonusRaw > 100) {
                        bonusRaw = 100 + Math.pow(bonusRaw - 100, 0.5);
                    }
                    comboMult = new Decimal(bonusRaw);
                }
            }

            return yieldMult.times(onCount).times(comboMult);
        }

        function processOfflineProgress(lastTime) {
            if (!settings.offlineProgress) return;

            const now = Date.now();
            const diffMs = now - lastTime;
            if (diffMs < 5000) return; // 5초 미만은 무시

            const delay = calculateDelay(hardware.speed);
            const totalTicks = Math.floor(diffMs / delay);
            if (totalTicks <= 0) return;

            const simTicks = Math.min(totalTicks, 100000);
            let totalGained = new Decimal(0);

            addLog(`오프라인 연산 시뮬레이션 중... (${Math.floor(diffMs / 1000)}초 분량)`);

            for (let i = 0; i < simTicks; i++) {
                totalGained = totalGained.plus(getTickYield(false));
            }

            if (totalTicks > simTicks) {
                const multiplier = totalTicks / simTicks;
                totalGained = totalGained.times(multiplier);
            }

            bits = bits.plus(totalGained);
            addLog(`오프라인 진행 완료: ${format(totalGained)} 비트를 생성했습니다.`);
        }

        function updateUI() {
            document.getElementById('bits').innerText = format(bits.floor());
            document.getElementById('lv-spark').innerText = ranks.spark;
            document.getElementById('lv-impulse').innerText = ranks.impulse;

            updateBtn('btn-spark', getRankCost('spark'), '');

            const impBtn = document.getElementById('btn-impulse');
            let reqSpark = Math.pow(ranks.impulse + 2, 2);
            // 충동 1레벨은 수치가 아니라 발상의 업그레이드 비용을 감소시킴 (UI 표시에서는 그대로)

            impBtn.querySelector('.cost-text').innerText = `필요: 발상 Lv.${reqSpark}`;
            if (ranks.spark >= reqSpark) impBtn.classList.add('affordable');
            else impBtn.classList.remove('affordable');
            impBtn.disabled = ranks.spark < reqSpark;

            // 하드웨어 버튼 해금 조건 변경
            // 열 추가(cols)은 발상 1 이상
            if (ranks.spark >= 1) document.getElementById('btn-group-cols').classList.remove('hidden');
            else document.getElementById('btn-group-cols').classList.add('hidden');

            // 최대 구매 버튼 표시 (최고 레벨 10 이상) & 업데이트
            if (maxSpark >= 10) {
                ['rows', 'cols', 'speed'].forEach(type => {
                    const btnGroup = document.getElementById(`btn-group-${type}`);
                    if (!btnGroup.classList.contains('hidden')) { // 상위 그룹이 보일 때만
                        const maxBtn = document.getElementById(`btn-${type}-max`);
                        maxBtn.classList.remove('hidden');

                        const calc = calcMaxAffordable(type);
                        maxBtn.querySelector('.max-count').innerText = `Max +${calc.count}`;
                        maxBtn.querySelector('.max-cost').innerText = format(calc.cost);

                        if (calc.count > 0 && bits.gte(calc.cost)) {
                            maxBtn.classList.add('affordable');
                            maxBtn.disabled = false;
                            maxBtn.querySelector('.max-cost').style.color = 'var(--neon)';
                        } else {
                            maxBtn.classList.remove('affordable');
                            maxBtn.disabled = true;
                            maxBtn.querySelector('.max-cost').style.color = '#aaa';
                        }
                    }
                });
            } else {
                ['rows', 'cols', 'speed'].forEach(type => {
                    document.getElementById(`btn-${type}-max`).classList.add('hidden');
                });
            }

            // 클럭 가속은 발상 2 이상
            if (ranks.spark >= 2) document.getElementById('btn-group-speed').classList.remove('hidden');
            else document.getElementById('btn-group-speed').classList.add('hidden');

            // 행 추가(rows)은 발상 3 이상 (기존 발상 4)
            if (ranks.spark >= 3) document.getElementById('btn-group-rows').classList.remove('hidden');
            else document.getElementById('btn-group-rows').classList.add('hidden');


            // 충동 버튼: 발상 4 이상이거나, 이미 충동을 한 번이라도 올렸다면 표시
            if (ranks.spark >= 4 || ranks.impulse > 0) document.getElementById('btn-impulse').classList.remove('hidden');
            else document.getElementById('btn-impulse').classList.add('hidden');

            updateHWBtn('btn-rows', 'rows');
            updateHWBtn('btn-cols', 'cols');

            // 클럭 가속 버튼 업데이트 (소프트캡 표시 추가)
            let speedEffect = `연산주기: ${Math.floor(calculateDelay(hardware.speed))}ms -> ${Math.floor(calculateDelay(hardware.speed + 1))}ms`;
            if (hardware.speed >= 12) {
                speedEffect += ` <span style="color: #f88; font-size: 10px;">(과부하)</span>`;
            }
            updateBtn('btn-speed', getHWCost('speed'), speedEffect);

            if (bits.gte(10)) document.getElementById('bit-container').classList.add('affordable');
            else document.getElementById('bit-container').classList.remove('affordable');

            updateMilestones('spark');
            updateMilestones('impulse');
            updateSettingsUI();
        }

        window.toggleSetting = function (key) {
            settings[key] = !settings[key];
            updateSettingsUI();
            saveGame();
            addLog(`설정 변경: ${key === 'offlineProgress' ? '오프라인 진행' : key} -> ${settings[key] ? 'ON' : 'OFF'}`);
        }

        function updateSettingsUI() {
            const offlineBtn = document.getElementById('setting-offline');
            if (offlineBtn) {
                offlineBtn.innerText = settings.offlineProgress ? "ON" : "OFF";
                offlineBtn.style.color = settings.offlineProgress ? "var(--neon)" : "#888";
                offlineBtn.style.borderColor = settings.offlineProgress ? "var(--neon)" : "#444";
            }
        }

        function updateHWBtn(id, type) {
            const btn = document.getElementById(id);
            let maxVal = type === 'cols' ? getMaxCols() : 4;
            let level = hardware[type];

            let mod = getHWModifier(type, level);
            let baseName = type === 'rows' ? "행 확장" : "열 확장";

            if (level >= maxVal) {
                let title = baseName + (mod.version ? ` ${mod.version}` : "") + " (최대)";
                btn.querySelector('.rank-title').innerText = title;
                btn.querySelector('.cost-text').innerText = "최대";
                btn.querySelector('.effect-info').innerText = "제한 도달";
                btn.classList.remove('affordable');
                btn.disabled = true;
            } else {
                let title = baseName + (mod.version ? ` ${mod.version}` : "");
                btn.querySelector('.rank-title').innerText = title;

                let effect = `${type === 'rows' ? '행' : '열'}: ${level} -> ${level + 1} (최대 ${maxVal})`;
                // mod.latestPenalty (회로 간섭 발생 등) 텍스트는 버튼에서 제외

                updateBtn(id, getHWCost(type), effect);
            }
        }

        function getHWModifier(type, level) {
            // Mk.N은 비용 가속 단계를 나타냄 (레벨이 아님)
            let mkTier = 1;  // 기본 Mk.1 (표시 안 함)
            let penalties = [];

            if (type === 'cols') {
                if (level >= 5) {
                    mkTier = 2;  // Mk.2: 회로 간섭 발생
                    penalties.push({
                        name: "회로 간섭 발생",
                        desc: "지수 가중치 (lv-3)^1.5 적용"
                    });
                }
                // 향후 확장: level >= 10이면 mkTier = 3 등
            }

            // 행은 현재 가속 없음 (mkTier = 1 유지)

            // 최고 Mk 버전 추적
            if (mkTier > maxMkTier) {
                maxMkTier = mkTier;
            }

            return {
                mkTier: mkTier,
                version: mkTier > 1 ? `Mk.${mkTier}` : "",
                allPenalties: penalties,
                latestPenalty: penalties.length > 0 ? penalties[penalties.length - 1].name : ""
            };
        }

        function updateBtn(id, cost, effectText) {
            const btn = document.getElementById(id);
            if (!btn || (btn.disabled && cost === 'MAX')) return;

            const costEl = btn.querySelector('.cost-text');
            const effEl = btn.querySelector('.effect-info');
            if (costEl) costEl.innerText = `${format(cost)} 비트 소모`;
            if (effEl) effEl.innerHTML = effectText; // HTML 허용 (페널티 메시지용)

            if (bits.gte(cost)) btn.classList.add('affordable');
            else btn.classList.remove('affordable');
            btn.disabled = bits.lt(cost);
        }

        function updateMilestones(id) {
            const msContainer = document.getElementById(`ms-${id}`);
            const data = rankData[id].ms;
            const curLv = ranks[id];
            let active = data.filter(m => m.lv <= curLv).pop();

            // 미래 마일스톤 필터링: spoilerMin 필드 기반
            let future = data.filter(m => {
                if (m.lv <= curLv) return false;
                if (m.spoilerMin && curLv < m.spoilerMin) return false;
                return true;
            }).slice(0, active ? 2 : 3);

            let html = '';
            if (active) html += `<div class="ms-item ms-active">✔ Lv.${active.lv}: ${active.desc}</div>`;
            future.forEach(m => {
                let desc = m.desc;
                // 스포일러 마스킹: 한 번도 도달한 적 없으면 ??? 처리 (spoilerMin이 있는 경우)
                // 발상 12레벨 등
                if (m.spoilerMin && maxSpark < m.lv) {
                    desc = "???";
                }
                html += `<div class="ms-item ms-future">🔒 Lv.${m.lv}: ${desc}</div>`;
            });
            msContainer.innerHTML = html;
        }

        function renderStats() {
            const list = document.getElementById('stats-list');
            let html = '';

            if (activeCategory === 'system') {
                // System Summary
                let sBonus = 1;
                let iBonus = 1;
                let hasBonus = false;

                if (ranks.spark >= 5) {
                    sBonus = ranks.spark * 0.5 + 1;
                    if (ranks.impulse >= 2) sBonus = sBonus ** 2;
                    hasBonus = true;
                }
                if (ranks.impulse >= 2) {
                    iBonus = ranks.impulse * 2 + 1;
                    hasBonus = true;
                }

                if (hasBonus) {
                    let total = sBonus * iBonus;
                    const bonusDetail = `발상 보너스(x${format(sBonus, 2)})와 충동 보너스(x${format(iBonus, 2)})가 결합된 최종 배율입니다.`;
                    html += `<div class="stat-line"><span class="stat-label">[효과]</span><button class="help-btn">? <span class="tooltip">${bonusDetail}</span></button> 최종 생산량 보너스: x${format(total, 3)}</div>`;
                }
                if (ranks.spark >= 6) {
                    let threshold = Math.ceil((hardware.rows * hardware.cols) / 2);
                    const comboDetail = `전구 개수의 50%(${threshold}개) 이상이 켜질 때부터 지수적 콤보 보너스가 발생합니다.`;
                    html += `<div class="stat-line"><span class="stat-label">[효과]</span><button class="help-btn">? <span class="tooltip">${comboDetail}</span></button> 콤보 시너지 임계치: ${threshold}개</div>`;
                }
                if (html === '') html = '<div style="padding:10px; color:#666;">현재 활성화된 시스템 효과가 없습니다.</div>';
            }
            else if (activeCategory === 'cognitive') {
                // Cognitive Stages (Spark / Impulse)
                const type = activeSubTab;
                if (type && ranks[type] > 0) {
                    const activeMs = rankData[type].ms.filter(m => m.lv <= ranks[type]);
                    activeMs.forEach(m => {
                        let desc = m.desc;
                        let detailText = m.detail || '';
                        if (type === 'spark' && m.lv === 5) {
                            let sBonus = ranks.spark * 0.5 + 1;
                            if (ranks.impulse >= 2) sBonus = sBonus ** 2;
                            detailText += `<br><br><b>현재 보너스:</b> x${format(sBonus, 3)}`;
                        }
                        if (type === 'impulse' && m.lv === 2) {
                            let iBonus = ranks.impulse * 2 + 1;
                            detailText += `<br><br><b>현재 보너스:</b> x${format(iBonus, 3)}`;
                        }
                        const helpBtn = detailText ? `<button class="help-btn">? <span class="tooltip">${detailText}</span></button>` : '';
                        html += `<div class="stat-line"><span class="stat-label">[Lv.${m.lv}]</span>${helpBtn} ${desc}</div>`;
                    });
                } else {
                    html = `<div style="padding:10px; color:#666;">${type === 'impulse' ? '충동 단계에 도달하지 않았거나 활성화된 효과가 없습니다.' : '발현된 효과가 없습니다.'}</div>`;
                }
            }
            else if (activeCategory === 'scaling') {
                // Research Version (Mk.N Tabs)
                const mkMatch = activeSubTab.match(/^mk(\d+)$/);
                if (mkMatch) {
                    const mkNum = parseInt(mkMatch[1]);
                    html = `<div class="scaling-info-container">`;

                    const types = ['rows', 'cols'];
                    let appliedAny = false;
                    types.forEach(type => {
                        const level = hardware[type];
                        const label = type === 'rows' ? '행 확장' : '열 확장';
                        const mod = getHWModifier(type, level);

                        if (mod.mkTier === mkNum) {
                            appliedAny = true;
                            let formula = type === 'rows' ? "lv ^ 1.5" : "(lv - 3) ^ 1.5";
                            let startLevel = type === 'cols' ? 5 : 999; // 행은 현재 가속 없음
                            html += `<div class="scaling-item" style="border:none; padding:0;">
                                        <div style="color:var(--neon); font-size:16px; margin-bottom:10px;"><b>${label} Mk.${mkNum}</b></div>
                                        <div class="scaling-detail">
                                            - 가속 수식: <b>${formula}</b><br>
                                            - 적용 시작: <b>레벨 ${startLevel}+</b><br>
                                            - 현재 레벨: <b>${level}</b>
                                        </div>
                                     </div>`;
                        }
                    });
                    if (!appliedAny) {
                        html += `<div style="color:#666; font-size:13px;">현재 이 버전이 적용된 하드웨어가 없습니다.</div>`;
                    }
                    html += `</div>`;
                } else {
                    html = '<div style="padding:10px; color:#666;">현재 발견하지 못한 연구 버전이거나 해당 정보가 없습니다.</div>';
                }
            }

            list.innerHTML = html;
        }

        function initGrid() {
            const grid = document.getElementById('bulb-grid');
            if (!grid) return;
            grid.style.gridTemplateColumns = `repeat(${hardware.cols}, 1fr)`;
            grid.innerHTML = '';
            for (let i = 0; i < hardware.rows * hardware.cols; i++) {
                let b = document.createElement('div'); b.className = 'bulb'; b.id = `bulb-${i}`;
                grid.appendChild(b);
            }
        }

        function flash(id) {
            const el = document.getElementById(`bulb-${id}`);
            if (el) { el.classList.add('on'); setTimeout(() => el.classList.remove('on'), 100); }
        }

        function addLog(msg) {
            const log = document.getElementById('game-log');
            log.innerHTML = `> ${msg}<br>${log.innerHTML}`;
        }

        // 자동 저장 시스템
        let saveTimer = 60;
        setInterval(() => {
            if (!isGamePaused) {
                saveTimer--;
                if (saveTimer <= 0) {
                    saveGame();
                    addLog("자동 저장이 완료되었습니다.");
                    saveTimer = 60;
                }
                const timerEl = document.getElementById('save-timer');
                if (timerEl) timerEl.innerText = saveTimer;
            }
        }, 1000);

        let gameLoopStarted = false;

        // 게임 초기화: rankData 로드 후 게임 시작
        window.onload = async () => {
            const loaded = await loadRankData();
            if (loaded) {
                loadGame();
                initGrid();

                // 최초 실행 시 3틱 보장 힌트 표시 (한 번만)
                const hintShown = localStorage.getItem('infCompHintShown');
                if (!hintShown && ranks.spark === 0 && bits.eq(0)) {
                    setTimeout(() => {
                        addLog("비밀인데, 운이 없어도 연산 3번마다 1개의 전구가 켜지는 것이 보장되어 있습니다.");
                        localStorage.setItem('infCompHintShown', 'true');
                    }, 1000); // 1초 후 표시
                }

                // 최초 실행 또는 강제 컷신 조건 체크
                const isFirstTime = localStorage.getItem('infCompFirstTime') !== 'false';
                if (isFirstTime) {
                    localStorage.setItem('infCompFirstTime', 'false');
                    showCutscene('intro');
                } else {
                    gameLoopStarted = true;
                    gameLoop();
                }
            }
        };
    </script>
</body>

</html>